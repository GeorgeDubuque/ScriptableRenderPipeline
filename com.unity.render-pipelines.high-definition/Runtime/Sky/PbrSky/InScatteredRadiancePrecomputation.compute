#pragma enable_d3d11_debug_symbols
#pragma only_renderers d3d11 ps4 xboxone vulkan metal switch
#pragma kernel main

#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Sky/PbrSky/PbrSkyCommon.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Sampling/Sampling.hlsl"

#define TABLE_SIZE uint3(PBRSKYCONFIG_IN_SCATTERED_RADIANCE_TABLE_SIZE_X, \
                         PBRSKYCONFIG_IN_SCATTERED_RADIANCE_TABLE_SIZE_Y, \
                         PBRSKYCONFIG_IN_SCATTERED_RADIANCE_TABLE_SIZE_Z)

RW_TEXTURE3D(float4, _InScatteredRadianceTable); // Emulate a 4D texture with a "deep" 3D texture

[numthreads(4, 4, 4)]
void main(uint3 dispatchThreadId : SV_DispatchThreadID)
{
    const float3 scale = rcp(TABLE_SIZE);
    const float3 bias  = 0.5 * scale;
    const uint   n     = PBRSKYCONFIG_IN_SCATTERED_RADIANCE_TABLE_SIZE_W / 2;

    // Let the hardware and the driver handle the ordering of the computation.
    uint3 tableCoord   = dispatchThreadId;
    uint  textureId    = dispatchThreadId.z / PBRSKYCONFIG_IN_SCATTERED_RADIANCE_TABLE_SIZE_Z;
    float aboveHorizon = (textureId < n) ? 1 : 0;

    // We don't care about the extremal points (boundary values).
    float3 uvw = tableCoord * scale + bias;

    float NdotV  = UnmapAerialPerspective(float3(uvw.xy, aboveHorizon)).x;
    float height = UnmapAerialPerspective(float3(uvw.xy, aboveHorizon)).y;
    float NdotL  = UnmapCosineOfZenithAngle(frac(uvw.z));
    float cosHor = GetCosineOfHorizonZenithAngle(height);
    float phiV   = UnmapAzimuthAngle(saturate((textureId & ~n) * rcp(n - 1)));

    // Convention: the normal vector N points upwards.
    // Utilize the rotational symmetry.
    float3 N = float3(0, 0, 1);
    float3 L = float3(sqrt(saturate(1 - NdotL * NdotL)), 0, NdotL);
    float3 V = float3(sqrt(saturate(1 - NdotV * NdotV)) * float2(cos(phiV), sin(phiV)), NdotV);

    float LdotV = dot(L, V);

    float3 radiance = 0;

    if (NdotL > cosHor)
    {
        // Sun is directly visible from this position.
        float3 transm  = SampleTransmittanceTexture(NdotL, height, false);
        float3 scatter = AtmosphereScatter(LdotV, height);

        radiance += scatter * transm * _SunRadiance;
    }
    else
    {
        // The sun is occluded by the planet.
    }

    // Integrate ground contribution.
    // The ground is a Lambertian reflector. It is basically a textured sphere light.
    {
        // We will importance sample according to the solid angle.
        // Hard to take transmittance, the phase function and the illumination into account...
        float R = _PlanetaryRadius;
        float h = height;
        float r = R + h;

        float3 origin      = r * N;
        float  cosAperture = -cosHor; // Cosine of the half-angle

        const float3 groundBrdf       = INV_PI * _GroundAlbedo;
        const int    numGroundSamples = 34;

        for (int i = 0; i < numGroundSamples; i++)
        {
            float2 f = Fibonacci2d(i, numGroundSamples);

            // Construct a direction around the up vector.
            float3 dir; float rcpPdf;
            SampleCone(f, cosAperture, dir, rcpPdf);

            float weight = rcpPdf * rcp(numGroundSamples);

            // Make it point towards the ground.
            dir = -dir;

            float  t = IntersectPlanetFromOutside(dir.z, height);
            float3 P = origin + t * dir;

            float3 groundNormal     = normalize(P);
            float  groundNdotL      = dot(groundNormal, L);
            float3 groundIrradiance = SampleGroundIrradianceTexture(groundNdotL);
            float3 groundRadiance   = groundIrradiance * groundBrdf * saturate(dot(groundNormal, -dir));

            float3 transm  = SampleTransmittanceTexture(dir.z, height, true);
            float3 scatter = AtmosphereScatter(dot(dir, V), height);

            radiance += weight * transm * scatter * groundRadiance;
        }
    }

    // TODO: deep compositing.
    float4 tableEntry = float4(radiance, 1);

    _InScatteredRadianceTable[tableCoord] = tableEntry;
}
